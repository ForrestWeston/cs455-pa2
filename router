#!/usr/bin/python
import string
import socket
import select
import readrouters

INF = 64
debugging = True

def debug(s):
    if debugging:
        print(s)
    return

class Router:
    def __init__(self, name, host, baseport, link_info):
       self.name, self.host, self.baseport, self.links = name, host, baseport, link_info
       self.routingTable = {} # key represents "from router" and value is a DistanceVector() that represents the costs to every other router
       
       debug(self.name)
       debug(self.host)
       debug(self.baseport)

    def initRoutingTable(self, routers_table):
        #Initialize routing table using self.links and RouterInfo
        # can access cost to link with self.routingTable[self.name].costToDict[neighbor]

        mine = DistanceVector(self.name, routers_table, self.links)
        self.routingTable[self.name] = mine # create dist vector for self

        for router in routers_table.keys(): # for each router
            if router == self.name:
                continue # skip own dist vect since already created
            vect = DistanceVector(router, routers_table)
            self.routingTable[router] = vect # create distance vector for all other nodes in network

        return # We need to implement a routing table that shows the next router to hop to as well
    
    def initNeighborSockets(self, routers_table):
        sockets = {}
        
        for neighbor in self.links.keys():
            localPort = self.links[neighbor].locallink # offset of routers baseport
            remotePort = self.links[neighbor].remotelink # offset of neighbors baseport
            neighborBasePort = routers_table[neighbor].baseport
            
            debug("binding to " + str(self.baseport + localPort))
            debug("connecting to " + str(neighborBasePort + remotePort))
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.bind((self.host, self.baseport+localPort))
            sock.connect((self.host, neighborBasePort+remotePort))
            
            sockets[sock] = neighbor
        return sockets
    
    def printRouteTable(self):
        print("-------------------------------------")
        print ("Routing Table For " + self.name)
        print ("<from>: {<to>: <cost>}")
        for vectors in self.routingTable.keys():
            print(vectors + ": " + str(self.routingTable[vectors].costToDict))
        print("-------------------------------------")
        return
    
    def updateLinkCost(self, dest, new_cost):
        if dest not in self.link_info.keys(): # verify that given destination is a neighbor
            debug(dest + " IS NOT A NEIGHBOR")
            return
        self.routingTable[self.name].costToDict[dest] = new_cost # update cost to neighbor in routing table
        return
    
    def sendUMessage(self, neighbor_socks):
        msg = "U "
        
        distVect = self.routingTable[self.name] # get distance vector of self
        
        for dest, cost in distVect.costToDict.items(): # build U message using distance vector
            msg += dest + " "
            msg += str(cost) + " "
            
        for sock in neighbor_socks.keys():
            try:
                sock.send(msg) # send U message to all neighbors
            except Exception:
                debug("failed to send to router " + neighbor_socks[sock])
        return
        

class DistanceVector:
    def __init__(self, for_router, routers_table, link_info=None): # Constructor for creating a distance vector with known link costs
        self.costToDict = {} # key represents the "router sending to" and value represents "cost to router"
        self.name = for_router # represents "from router"

        for router in routers_table.keys():         # for each router
            if router == for_router:                    # set cost to 0 if it is self
                self.costToDict[router] = 0
            elif link_info is not None and router in link_info.keys():            #   set the cost of the link if neighbor
                self.costToDict[router] = link_info[router].cost
            else:
                self.costToDict[router] = INF           #   otherwise set the cost to infinity

if __name__=='__main__':
    import sys
    # If no poison control
        # sys.argv[1] = 'testdir'
        # sys.argv[2] = 'routername'
    # If poison control
        # sys.argv[1] = '-p'
        # sys.argv[2] = 'testdir'
        # sys.argv[3] = 'routername'
        
    # read in cmd line parameters
    if len(sys.argv) == 3:
        poison_rev = False;
        testdir = sys.argv[1]
        routername = sys.argv[2]
    elif len(sys.argv) == 4 and sys.argv[1] == "-p":
        poison_rev = True;
        testdir = sys.argv[2]
        routername = sys.argv[3]

    # Use readrouters() to get table of all routers present in network
    routersTable = readrouters.readrouters(testdir)
    # Use readlinks() to get cost of each link to neighbors
    linksTable = readrouters.readlinks(testdir, routername)

    # Initialize a new Router()
    node = Router(routername, routersTable[routername].host, routersTable[routername].baseport, linksTable)
    node.initRoutingTable(routersTable) # use routersTable to know how many nodes in network

    # Create a socket for the base port
    baseSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    baseSock.bind((node.host, node.baseport)) # Bind the socket to the addr

    # Create connected sockets for neighbors
    neighborSocks = node.initNeighborSockets(routersTable) # key represents socket and value reperesents the neighbor associated with socket

    inputs = [baseSock] # Sockets from which we expect to read
    for sock in neighborSocks.keys():
        inputs.append(sock) # add all neighbor sockets to inputs as well

    # Select loop
    while 1:
        # wait for a socket to be ready
        readable, writable, exceptional = select.select(inputs, [], [], 10) # only need readable set for project so writefds and exceptionfs is set to []

        # handle sockets that are ready to receive data
        for s in readable:
            tableUpdated = False
            
            if s is baseSock:
                data, addr = s.recvfrom(2056) # received L or P messages from socket s
            else:
                try:
                    data = s.recv(2056) # received U message from socket s
                except Exception:
                    continue
        
            command = string.split(data) # parse received message
            
            if command[0] == 'L':
                node.updateLinkCost(command[1], command[2]) # update link cost to a neighbor
                tableUpdated = True
            elif command[0] == 'U':
                neighbor = neighborSocks[s] # get neighbor that is sending the update message
                debug(node.name + ": received U message from " + neighbor)
                # command[1] command[2].... is in the format of d1 cost1 d2 cost2 dn costn where dn and costn is cost of reaching dn from the neighbor
                
                # take received distance vector from neighbor and update node.routingTable using the Bellman-Ford Equation (pg. 373)
                
                # if there are changes to routing table
                    # tableUpdated = True
            elif command[0] == 'P':
                if len(command) > 1 and command[1] == node.name: # print table for this router only
                    node.printRouteTable()
                else:
                    node.printRouteTable() # print every routing table for every router
                    
            if tableUpdated:
                node.sendUMessages(neighborSocks) # send U messages to all neighbors if theres been changes to the routing table or own distance vector
                # print(node.name - dest: <d> cost: <c> nexthop: <n>) for every change in dest <d> (?)
                

        # send U-message to each of its neighbors every 30 seconds after a timeout occurs
        if (len(readable) == 0):
            node.sendUMessage(neighborSocks)
            debug(node.name + ": timeout!")

